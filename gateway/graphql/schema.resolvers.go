package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.38

import (
	"context"
	"fmt"

	"github.com/rs/zerolog"
	categorydomain "github.com/vediagames/platform/category/domain"
	gamedomain "github.com/vediagames/platform/game/domain"
	"github.com/vediagames/platform/gateway/graphql/generated"
	"github.com/vediagames/platform/gateway/graphql/model"
	notificationdomain "github.com/vediagames/platform/notification/domain"
	searchdomain "github.com/vediagames/platform/search/domain"
	sectiondomain "github.com/vediagames/platform/section/domain"
	tagdomain "github.com/vediagames/platform/tag/domain"
)

// SendEmail is the resolver for the sendEmail field.
func (r *mutationResolver) SendEmail(ctx context.Context, request model.SendEmailRequest) (bool, error) {
	err := r.emailClient.Email(ctx, notificationdomain.EmailRequest{
		To: notificationdomain.User{
			Email: "antonio.jelic@vedia.si",
			Name:  "Antonio Jelic",
		},
		From: notificationdomain.User{
			Email: request.From,
			Name:  "platform Contact form",
		},
		Name:    request.Name,
		Subject: request.Subject,
		Body:    request.Body,
	})
	if err != nil {
		return false, fmt.Errorf("failed to email: %w", err)
	}

	return true, nil
}

// CreateGame is the resolver for the createGame field.
func (r *mutationResolver) CreateGame(ctx context.Context, request model.CreateGameRequest) (*model.CreateGameResponse, error) {
	gameRes, err := r.gameService.Create(ctx, request.Domain())
	if err != nil {
		return nil, fmt.Errorf("failed to create: %w", err)
	}

	return &model.CreateGameResponse{
		Game: model.Game{}.FromDomain(gameRes.Data),
	}, nil
}

// UpdateGame is the resolver for the updateGame field.
func (r *mutationResolver) UpdateGame(ctx context.Context, request model.UpdateGameRequest) (*model.UpdateGameResponse, error) {
	gameRes, err := r.gameService.Edit(ctx, request.Domain())
	if err != nil {
		return nil, fmt.Errorf("failed to edit: %w", err)
	}

	return &model.UpdateGameResponse{
		Game: model.Game{}.FromDomain(gameRes.Data),
	}, nil
}

// DeleteGame is the resolver for the deleteGame field.
func (r *mutationResolver) DeleteGame(ctx context.Context, request model.DeleteGameRequest) (bool, error) {
	var (
		err error
	)

	switch {
	case request.ID != nil:
		_, err = r.gameService.Remove(ctx, gamedomain.RemoveRequest{
			ID: *request.ID,
		})
	case request.Slug != nil:
		_, err = r.gameService.Remove(ctx, gamedomain.RemoveRequest{
			Slug: *request.Slug,
		})
	}

	if err != nil {
		return false, fmt.Errorf("failed to remove: %w", err)
	}

	return true, nil
}

// MostPlayedGames is the resolver for the mostPlayedGames field.
func (r *queryResolver) MostPlayedGames(ctx context.Context, request model.MostPlayedGamesRequest) (*model.MostPlayedGamesResponse, error) {
	gameRes, err := r.gameService.GetMostPlayedByDays(ctx, gamedomain.GetMostPlayedByDaysRequest{
		Page:     request.Page,
		Limit:    request.Limit,
		MaxDays:  request.MaxDays,
		Language: gamedomain.Language(request.Language),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get: %w", err)
	}

	return &model.MostPlayedGamesResponse{
		Games: model.Games{}.FromDomain(gameRes.Data),
	}, nil
}

// FreshGames is the resolver for the freshGames field.
func (r *queryResolver) FreshGames(ctx context.Context, request model.FreshGamesRequest) (*model.FreshGamesResponse, error) {
	gameRes, err := r.gameService.GetFresh(ctx, gamedomain.GetFreshRequest{
		Page:     request.Page,
		Limit:    request.Limit,
		MaxDays:  request.MaxDays,
		Language: gamedomain.Language(request.Language),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get: %w", err)
	}

	return &model.FreshGamesResponse{
		Games: model.Games{}.FromDomain(gameRes.Data),
	}, nil
}

// Games is the resolver for the games field.
func (r *queryResolver) Games(ctx context.Context, request model.GamesRequest) (*model.GamesResponse, error) {
	query := ""

	if request.Query != nil {
		query = *request.Query
	}

	gameRes, err := r.gameService.List(ctx, gamedomain.ListRequest{
		Language:       gamedomain.Language(request.Language),
		Page:           request.Page,
		Limit:          request.Limit,
		AllowDeleted:   request.AllowDeleted,
		AllowInvisible: request.AllowInvisible,
		Sort:           gamedomain.SortingMethod(request.Sort.Domain()),
		CategoryIDRefs: request.Categories,
		TagIDRefs:      request.Tags,
		IDRefs:         request.Ids,
		ExcludedIDRefs: request.ExcludedGameIDs,
		Query:          query,
		Slugs:          request.Slugs,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to list: %w", err)
	}

	return &model.GamesResponse{
		Games: model.Games{}.FromDomain(gameRes.Data),
	}, nil
}

// Game is the resolver for the game field.
func (r *queryResolver) Game(ctx context.Context, request model.GameRequest) (*model.GameResponse, error) {
	gameRes, err := r.gameService.Get(ctx, gamedomain.GetRequest{
		Field:    gamedomain.GetByField(request.Field),
		Value:    request.Value,
		Language: gamedomain.Language(request.Language),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get: %w", err)
	}

	return &model.GameResponse{
		Game: model.Game{}.FromDomain(gameRes.Data),
	}, nil
}

// TrendingGames is the resolver for the trendingGames field.
func (r *queryResolver) TrendingGames(ctx context.Context, language model.Language) ([]*model.ListGame, error) {
	// TODO: BL logic should be in game service.
	const amountOfGamesNeeded = 15

	res := make([]*model.ListGame, 0, amountOfGamesNeeded)

	selectedGamesRes, err := r.gameService.List(ctx, gamedomain.ListRequest{
		Language: gamedomain.Language(language),
		Page:     1,
		Limit:    len(trendingGames),
		Sort:     gamedomain.SortingMethodMostPopular,
		Slugs:    trendingGames.Slugs(),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get games: %w", err)
	}

	// Second batch of games, if the amount needed is not fulfilled.
	var randomGamesRes gamedomain.ListResponse
	if len(selectedGamesRes.Data.Data) < amountOfGamesNeeded {
		amountToFetch := amountOfGamesNeeded - len(selectedGamesRes.Data.Data)

		randomGamesRes, err = r.gameService.List(ctx, gamedomain.ListRequest{
			Language:       gamedomain.Language(language),
			Page:           1,
			Limit:          amountToFetch,
			Sort:           gamedomain.SortingMethodRandom,
			ExcludedIDRefs: selectedGamesRes.Data.IDs(),
		})
		if err != nil {
			return nil, fmt.Errorf("failed to get more games: %w", err)
		}
	}

	for _, game := range selectedGamesRes.Data.Data {
		trendingGame := trendingGames.FindBySlug(game.Slug)
		if trendingGame.IsZero() {
			zerolog.Ctx(ctx).Warn().Str("slug", game.Slug).Msg("trending game not found")
			continue
		}

		res = append(res, &model.ListGame{
			Game:        model.Game{}.FromDomain(game),
			Label:       &trendingGame.Label,
			Description: &trendingGame.Description,
		})
	}

	for _, game := range randomGamesRes.Data.Data {
		res = append(res, &model.ListGame{
			Game: model.Game{}.FromDomain(game),
		})
	}

	return res, nil
}

// PromotedGame is the resolver for the promotedGame field.
func (r *queryResolver) PromotedGame(ctx context.Context, language model.Language) (*model.ListGame, error) {
	gamesRes, err := r.Games(ctx, model.GamesRequest{
		Language: language,
		Page:     1,
		Limit:    1,
		Slugs:    []string{promotedGame.Slug},
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get games: %w", err)
	}

	if len(gamesRes.Games.Data) == 0 {
		return nil, fmt.Errorf("promoted game with slug %q not found", promotedGame.Slug)
	}

	return &model.ListGame{
		Game:        gamesRes.Games.Data[0],
		Label:       &promotedGame.Label,
		Description: &promotedGame.Description,
	}, nil
}

// PopularGames is the resolver for the popularGames field.
func (r *queryResolver) PopularGames(ctx context.Context, language model.Language) ([]*model.ListGame, error) {
	const amountOfGamesNeeded = 4

	sort := model.SortingMethodMostPopular
	res := make([]*model.ListGame, 0, amountOfGamesNeeded)
	fullGames := make([]*model.Game, 0, amountOfGamesNeeded)

	gamesRes, err := r.Games(ctx, model.GamesRequest{
		Language: language,
		Page:     1,
		Limit:    4,
		Sort:     &sort,
		Slugs:    popularGames.Slugs(),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get games: %w", err)
	}

	fullGames = append(fullGames, gamesRes.Games.Data...)

	if len(fullGames) < amountOfGamesNeeded {
		amountToFetch := amountOfGamesNeeded - len(gamesRes.Games.Data)

		gamesRes, err = r.Games(ctx, model.GamesRequest{
			Language:        language,
			Page:            1,
			Limit:           amountToFetch,
			Sort:            &sort,
			ExcludedGameIDs: gamesRes.Games.IDs(),
		})
		if err != nil {
			return nil, fmt.Errorf("failed to get more games: %w", err)
		}

		fullGames = append(fullGames, gamesRes.Games.Data...)
	}

	for _, game := range fullGames {
		popularGame := popularGames.FindBySlug(game.Slug)
		if popularGame.IsZero() {
			zerolog.Ctx(ctx).Warn().Str("slug", game.Slug).Msg("popular game not found")
			continue
		}

		res = append(res, &model.ListGame{
			Game:        game,
			Label:       &popularGame.Label,
			Description: &popularGame.Description,
		})
	}

	return res, nil
}

// PickedByEditor is the resolver for the pickedByEditor field.
func (r *queryResolver) PickedByEditor(ctx context.Context, language model.Language) (*model.ListGame, error) {
	gamesRes, err := r.Games(ctx, model.GamesRequest{
		Language: language,
		Page:     1,
		Limit:    1,
		Slugs:    []string{pickedByEditor.Slug},
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get games: %w", err)
	}

	if len(gamesRes.Games.Data) == 0 {
		return nil, fmt.Errorf("picked by editor game with slug %q not found", pickedByEditor.Slug)
	}

	return &model.ListGame{
		Game:        gamesRes.Games.Data[0],
		Label:       &pickedByEditor.Label,
		Description: &pickedByEditor.Description,
	}, nil
}

// Categories is the resolver for the categories field.
func (r *queryResolver) Categories(ctx context.Context, request model.CategoriesRequest) (*model.CategoriesResponse, error) {
	categoryRes, err := r.categoryService.List(ctx, categorydomain.ListRequest{
		Language:       categorydomain.Language(request.Language),
		Page:           request.Page,
		Limit:          request.Limit,
		AllowDeleted:   request.AllowDeleted,
		AllowInvisible: request.AllowInvisible,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to list: %w", err)
	}

	return &model.CategoriesResponse{
		Categories: model.Categories{}.FromDomain(categoryRes.Data),
	}, nil
}

// Category is the resolver for the category field.
func (r *queryResolver) Category(ctx context.Context, request model.CategoryRequest) (*model.CategoryResponse, error) {
	categoryRes, err := r.categoryService.Get(ctx, categorydomain.GetRequest{
		Field:    categorydomain.GetByField(request.Field),
		Value:    request.Value,
		Language: categorydomain.Language(request.Language),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get: %w", err)
	}

	return &model.CategoryResponse{
		Category: model.Category{}.FromDomain(categoryRes.Data),
	}, nil
}

// Tags is the resolver for the tags field.
func (r *queryResolver) Tags(ctx context.Context, request model.TagsRequest) (*model.TagsResponse, error) {
	tagRes, err := r.tagService.List(ctx, tagdomain.ListRequest{
		Language:       tagdomain.Language(request.Language),
		Page:           request.Page,
		Limit:          request.Limit,
		AllowDeleted:   request.AllowDeleted,
		AllowInvisible: request.AllowInvisible,
		Sort:           tagdomain.SortingMethod(request.Sort.Domain()),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to list: %w", err)
	}

	return &model.TagsResponse{
		Tags: model.Tags{}.FromDomain(tagRes.Data),
	}, nil
}

// Tag is the resolver for the tag field.
func (r *queryResolver) Tag(ctx context.Context, request model.TagRequest) (*model.TagResponse, error) {
	tagRes, err := r.tagService.Get(ctx, tagdomain.GetRequest{
		Field:    tagdomain.GetByField(request.Field),
		Value:    request.Value,
		Language: tagdomain.Language(request.Language),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get: %w", err)
	}

	return &model.TagResponse{
		Tag: model.Tag{}.FromDomain(tagRes.Data),
	}, nil
}

// Sections is the resolver for the sections field.
func (r *queryResolver) Sections(ctx context.Context, request model.SectionsRequest) (*model.SectionsResponse, error) {
	sectionRes, err := r.sectionService.List(ctx, sectiondomain.ListRequest{
		Language:       sectiondomain.Language(request.Language),
		Page:           request.Page,
		Limit:          request.Limit,
		AllowDeleted:   request.AllowDeleted,
		AllowInvisible: request.AllowInvisible,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to list: %w", err)
	}

	return &model.SectionsResponse{
		Sections: model.Sections{}.FromDomain(sectionRes.Data),
	}, nil
}

// Section is the resolver for the section field.
func (r *queryResolver) Section(ctx context.Context, request model.SectionRequest) (*model.SectionResponse, error) {
	sectionRes, err := r.sectionService.Get(ctx, sectiondomain.GetRequest{
		Field:    sectiondomain.GetByField(request.Field),
		Value:    request.Value,
		Language: sectiondomain.Language(request.Language),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get: %w", err)
	}

	return &model.SectionResponse{
		Section: model.Section{}.FromDomain(sectionRes.Data),
	}, nil
}

// PlacedSections is the resolver for the placedSections field.
func (r *queryResolver) PlacedSections(ctx context.Context, request model.PlacedSectionsRequest) (*model.PlacedSectionsResponse, error) {
	sectionRes, err := r.sectionService.GetPlaced(ctx, sectiondomain.GetPlacedRequest{
		Language:       sectiondomain.Language(request.Language),
		AllowDeleted:   false,
		AllowInvisible: false,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get: %w", err)
	}

	return &model.PlacedSectionsResponse{
		PlacedSections: model.PlacedSections{}.FromDomain(sectionRes),
	}, nil
}

// Search is the resolver for the search field.
func (r *queryResolver) Search(ctx context.Context, request model.SearchRequest) (*model.SearchResponse, error) {
	searchRes, err := r.searchService.Search(ctx, searchdomain.SearchRequest{
		Query:          request.Query,
		MaxGames:       request.MaxGames,
		MaxTags:        request.MaxTags,
		AllowDeleted:   request.AllowDeleted,
		AllowInvisible: request.AllowInvisible,
		Language:       searchdomain.Language(request.Language),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to search: %w", err)
	}

	return &model.SearchResponse{
		SearchItems: model.SearchItems{}.FromDomain(searchRes),
	}, nil
}

// FullSearch is the resolver for the fullSearch field.
func (r *queryResolver) FullSearch(ctx context.Context, request model.FullSearchRequest) (*model.SearchResponse, error) {
	searchRes, err := r.searchService.FullSearch(ctx, searchdomain.FullSearchRequest{
		Query:          request.Query,
		Page:           request.Page,
		Limit:          request.Limit,
		AllowDeleted:   request.AllowDeleted,
		AllowInvisible: request.AllowInvisible,
		Sort:           searchdomain.SortingMethod(request.Sort.Domain()),
		Language:       searchdomain.Language(request.Language),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to search: %w", err)
	}

	return &model.SearchResponse{
		SearchItems: model.SearchItems{}.FromDomain(searchRes),
	}, nil
}

// RandomProviderGame is the resolver for the randomProviderGame field.
func (r *queryResolver) RandomProviderGame(ctx context.Context) (*model.RandomProviderGameResponse, error) {
	fetcherRes, err := r.fetcherClient.Fetch()
	if err != nil {
		return nil, fmt.Errorf("failed to fetch game: %w", err)
	}

	res := model.RandomProviderGameResponse(fetcherRes)

	return &res, nil
}

// AvailableLanguages is the resolver for the availableLanguages field.
func (r *queryResolver) AvailableLanguages(ctx context.Context) (*model.AvailableLanguagesResponse, error) {
	return &model.AvailableLanguagesResponse{
		Languages: []*model.AvailableLanguage{
			{
				Code: model.LanguageEn,
				Name: "English",
			},
		},
	}, nil
}

// PromotedTags is the resolver for the promotedTags field.
func (r *queryResolver) PromotedTags(ctx context.Context, language model.Language) ([]*model.PromotedTag, error) {
	return []*model.PromotedTag{
		{
			ID:        4,
			Slug:      "brain",
			Name:      "Brain",
			Icon:      fmt.Sprintf("%s/tags/brain/icon.svg", r.contentURL),
			Thumbnail: fmt.Sprintf("%s/tags/brain/promo_thumb.png", r.contentURL),
		},
		{
			ID:        18,
			Slug:      "match-3",
			Name:      "Match-3",
			Icon:      fmt.Sprintf("%s/tags/match-3/icon.svg", r.contentURL),
			Thumbnail: fmt.Sprintf("%s/tags/match-3/promo_thumb.png", r.contentURL),
		},
		{
			ID:        24,
			Slug:      "word",
			Name:      "Word",
			Icon:      fmt.Sprintf("%s/tags/word/icon.svg", r.contentURL),
			Thumbnail: fmt.Sprintf("%s/tags/word/promo_thumb.png", r.contentURL),
		},
		{
			ID:        22,
			Slug:      "time-management",
			Name:      "Time management",
			Icon:      fmt.Sprintf("%s/tags/time-management/icon.svg", r.contentURL),
			Thumbnail: fmt.Sprintf("%s/tags/time-management/promo_thumb.png", r.contentURL),
		},
	}, nil
}

// TopTags is the resolver for the topTags field.
func (r *queryResolver) TopTags(ctx context.Context, language model.Language) (*model.TagsResponse, error) {
	res, err := r.tagService.List(ctx, tagdomain.ListRequest{
		Language: tagdomain.LanguageEnglish,
		Page:     1,
		Limit:    7,
		IDRefs: []int{
			11, // cooking
			18, // match-3
			4,  // brain
			22, // time-management
			17, // mahjong
			12, // educational
			25, // solitaire
		},
	})
	if err != nil {
		return nil, fmt.Errorf("failed to list: %w", err)
	}

	return &model.TagsResponse{
		Tags: model.Tags{}.FromDomain(res.Data),
	}, nil
}

// WhatOthersPlay is the resolver for the whatOthersPlay field.
func (r *queryResolver) WhatOthersPlay(ctx context.Context, language model.Language) (*model.GamesResponse, error) {
	res, err := r.gameService.GetMostPlayedByDays(ctx, gamedomain.GetMostPlayedByDaysRequest{
		Page:       1,
		Limit:      10,
		MaxDays:    14,
		Language:   gamedomain.LanguageEnglish,
		MobileOnly: false,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get most played games: %w", err)
	}

	if len(res.Data.Data) != 0 {
		return &model.GamesResponse{
			Games: model.Games{}.FromDomain(res.Data),
		}, nil
	}

	topRes, err := r.gameService.List(ctx, gamedomain.ListRequest{
		Page:     1,
		Limit:    10,
		Language: gamedomain.LanguageEnglish,
		Sort:     gamedomain.SortingMethodMostPopular,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to list: %w", err)
	}

	return &model.GamesResponse{
		Games: model.Games{}.FromDomain(topRes.Data),
	}, nil
}

// Quote is the resolver for the quote field.
func (r *queryResolver) Quote(ctx context.Context, language model.Language) (*model.Quote, error) {
	res, err := r.quoteService.Get()
	if err != nil {
		return nil, fmt.Errorf("failed to get: %w", err)
	}

	return &model.Quote{
		Message:   res.Quote,
		Author:    res.Author,
		ExpiresAt: res.ExpiresAt.UTC().String(),
	}, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
func (r *queryResolver) MostPlayedGame(ctx context.Context, language model.Language) (*model.ListGame, error) {
	gamesRes, err := r.MostPlayedGames(ctx, model.MostPlayedGamesRequest{
		Page:     1,
		Limit:    1,
		MaxDays:  14,
		Language: language,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get most played games: %w", err)
	}

	if len(gamesRes.Games.Data) == 0 {
		return nil, nil
	}

	return &model.ListGame{
		Game: gamesRes.Games.Data[0],
	}, nil
}
