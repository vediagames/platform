package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.34

import (
	"context"
	"fmt"

	categorydomain "github.com/vediagames/platform/category/domain"
	gamedomain "github.com/vediagames/platform/game/domain"
	"github.com/vediagames/platform/gateway/graphql/generated"
	"github.com/vediagames/platform/gateway/graphql/model"
	notificationdomain "github.com/vediagames/platform/notification/domain"
	searchdomain "github.com/vediagames/platform/search/domain"
	sectiondomain "github.com/vediagames/platform/section/domain"
	tagdomain "github.com/vediagames/platform/tag/domain"
)

// SendEmail is the resolver for the sendEmail field.
func (r *mutationResolver) SendEmail(ctx context.Context, request model.SendEmailRequest) (bool, error) {
	err := r.emailClient.Email(ctx, notificationdomain.EmailRequest{
		To: notificationdomain.User{
			Email: "antonio.jelic@vedia.si",
			Name:  "Antonio Jelic",
		},
		From: notificationdomain.User{
			Email: request.From,
			Name:  "platform Contact form",
		},
		Name:    request.Name,
		Subject: request.Subject,
		Body:    request.Body,
	})
	if err != nil {
		return false, fmt.Errorf("failed to email: %w", err)
	}

	return true, nil
}

// CreateGame is the resolver for the createGame field.
func (r *mutationResolver) CreateGame(ctx context.Context, request model.CreateGameRequest) (*model.CreateGameResponse, error) {
	gameRes, err := r.gameService.Create(ctx, request.Domain())
	if err != nil {
		return nil, fmt.Errorf("failed to create: %w", err)
	}

	return &model.CreateGameResponse{
		Game: model.Game{}.FromDomain(gameRes.Data),
	}, nil
}

// UpdateGame is the resolver for the updateGame field.
func (r *mutationResolver) UpdateGame(ctx context.Context, request model.UpdateGameRequest) (*model.UpdateGameResponse, error) {
	gameRes, err := r.gameService.Edit(ctx, request.Domain())
	if err != nil {
		return nil, fmt.Errorf("failed to edit: %w", err)
	}

	return &model.UpdateGameResponse{
		Game: model.Game{}.FromDomain(gameRes.Data),
	}, nil
}

// DeleteGame is the resolver for the deleteGame field.
func (r *mutationResolver) DeleteGame(ctx context.Context, request model.DeleteGameRequest) (bool, error) {
	var (
		err error
	)

	switch {
	case request.ID != nil:
		_, err = r.gameService.Remove(ctx, gamedomain.RemoveRequest{
			ID: *request.ID,
		})
	case request.Slug != nil:
		_, err = r.gameService.Remove(ctx, gamedomain.RemoveRequest{
			Slug: *request.Slug,
		})
	}

	if err != nil {
		return false, fmt.Errorf("failed to remove: %w", err)
	}

	return true, nil
}

// MostPlayedGames is the resolver for the mostPlayedGames field.
func (r *queryResolver) MostPlayedGames(ctx context.Context, request model.MostPlayedGamesRequest) (*model.MostPlayedGamesResponse, error) {
	gameRes, err := r.gameService.GetMostPlayedByDays(ctx, gamedomain.GetMostPlayedByDaysRequest{
		Page:     request.Page,
		Limit:    request.Limit,
		MaxDays:  request.MaxDays,
		Language: gamedomain.Language(request.Language),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get: %w", err)
	}

	return &model.MostPlayedGamesResponse{
		Games: model.Games{}.FromDomain(gameRes.Data),
	}, nil
}

// FreshGames is the resolver for the freshGames field.
func (r *queryResolver) FreshGames(ctx context.Context, request model.FreshGamesRequest) (*model.FreshGamesResponse, error) {
	gameRes, err := r.gameService.GetFresh(ctx, gamedomain.GetFreshRequest{
		Page:     request.Page,
		Limit:    request.Limit,
		MaxDays:  request.MaxDays,
		Language: gamedomain.Language(request.Language),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get: %w", err)
	}

	return &model.FreshGamesResponse{
		Games: model.Games{}.FromDomain(gameRes.Data),
	}, nil
}

// Games is the resolver for the games field.
func (r *queryResolver) Games(ctx context.Context, request model.GamesRequest) (*model.GamesResponse, error) {
	gameRes, err := r.gameService.List(ctx, gamedomain.ListRequest{
		Language:       gamedomain.Language(request.Language),
		Page:           request.Page,
		Limit:          request.Limit,
		AllowDeleted:   request.AllowDeleted,
		AllowInvisible: request.AllowInvisible,
		Sort:           gamedomain.SortingMethod(request.Sort.Domain()),
		CategoryIDRefs: request.Categories,
		TagIDRefs:      request.Tags,
		IDRefs:         request.Ids,
		ExcludedIDRefs: request.ExcludedGameIDs,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to list: %w", err)
	}

	return &model.GamesResponse{
		Games: model.Games{}.FromDomain(gameRes.Data),
	}, nil
}

// Game is the resolver for the game field.
func (r *queryResolver) Game(ctx context.Context, request model.GameRequest) (*model.GameResponse, error) {
	gameRes, err := r.gameService.Get(ctx, gamedomain.GetRequest{
		Field:    gamedomain.GetByField(request.Field),
		Value:    request.Value,
		Language: gamedomain.Language(request.Language),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get: %w", err)
	}

	return &model.GameResponse{
		Game: model.Game{}.FromDomain(gameRes.Data),
	}, nil
}

// Categories is the resolver for the categories field.
func (r *queryResolver) Categories(ctx context.Context, request model.CategoriesRequest) (*model.CategoriesResponse, error) {
	categoryRes, err := r.categoryService.List(ctx, categorydomain.ListRequest{
		Language:       categorydomain.Language(request.Language),
		Page:           request.Page,
		Limit:          request.Limit,
		AllowDeleted:   request.AllowDeleted,
		AllowInvisible: request.AllowInvisible,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to list: %w", err)
	}

	return &model.CategoriesResponse{
		Categories: model.Categories{}.FromDomain(categoryRes.Data),
	}, nil
}

// Category is the resolver for the category field.
func (r *queryResolver) Category(ctx context.Context, request model.CategoryRequest) (*model.CategoryResponse, error) {
	categoryRes, err := r.categoryService.Get(ctx, categorydomain.GetRequest{
		Field:    categorydomain.GetByField(request.Field),
		Value:    request.Value,
		Language: categorydomain.Language(request.Language),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get: %w", err)
	}

	return &model.CategoryResponse{
		Category: model.Category{}.FromDomain(categoryRes.Data),
	}, nil
}

// Tags is the resolver for the tags field.
func (r *queryResolver) Tags(ctx context.Context, request model.TagsRequest) (*model.TagsResponse, error) {
	tagRes, err := r.tagService.List(ctx, tagdomain.ListRequest{
		Language:       tagdomain.Language(request.Language),
		Page:           request.Page,
		Limit:          request.Limit,
		AllowDeleted:   request.AllowDeleted,
		AllowInvisible: request.AllowInvisible,
		Sort:           tagdomain.SortingMethod(request.Sort.Domain()),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to list: %w", err)
	}

	return &model.TagsResponse{
		Tags: model.Tags{}.FromDomain(tagRes.Data),
	}, nil
}

// Tag is the resolver for the tag field.
func (r *queryResolver) Tag(ctx context.Context, request model.TagRequest) (*model.TagResponse, error) {
	tagRes, err := r.tagService.Get(ctx, tagdomain.GetRequest{
		Field:    tagdomain.GetByField(request.Field),
		Value:    request.Value,
		Language: tagdomain.Language(request.Language),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get: %w", err)
	}

	return &model.TagResponse{
		Tag: model.Tag{}.FromDomain(tagRes.Data),
	}, nil
}

// Sections is the resolver for the sections field.
func (r *queryResolver) Sections(ctx context.Context, request model.SectionsRequest) (*model.SectionsResponse, error) {
	sectionRes, err := r.sectionService.List(ctx, sectiondomain.ListRequest{
		Language:       sectiondomain.Language(request.Language),
		Page:           request.Page,
		Limit:          request.Limit,
		AllowDeleted:   request.AllowDeleted,
		AllowInvisible: request.AllowInvisible,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to list: %w", err)
	}

	return &model.SectionsResponse{
		Sections: model.Sections{}.FromDomain(sectionRes.Data),
	}, nil
}

// Section is the resolver for the section field.
func (r *queryResolver) Section(ctx context.Context, request model.SectionRequest) (*model.SectionResponse, error) {
	sectionRes, err := r.sectionService.Get(ctx, sectiondomain.GetRequest{
		Field:    sectiondomain.GetByField(request.Field),
		Value:    request.Value,
		Language: sectiondomain.Language(request.Language),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get: %w", err)
	}

	return &model.SectionResponse{
		Section: model.Section{}.FromDomain(sectionRes.Data),
	}, nil
}

// PlacedSections is the resolver for the placedSections field.
func (r *queryResolver) PlacedSections(ctx context.Context, request model.PlacedSectionsRequest) (*model.PlacedSectionsResponse, error) {
	sectionRes, err := r.sectionService.GetPlaced(ctx, sectiondomain.GetPlacedRequest{
		Language:       sectiondomain.Language(request.Language),
		AllowDeleted:   false,
		AllowInvisible: false,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get: %w", err)
	}

	return &model.PlacedSectionsResponse{
		PlacedSections: model.PlacedSections{}.FromDomain(sectionRes),
	}, nil
}

// Search is the resolver for the search field.
func (r *queryResolver) Search(ctx context.Context, request model.SearchRequest) (*model.SearchResponse, error) {
	searchRes, err := r.searchService.Search(ctx, searchdomain.SearchRequest{
		Query:          request.Query,
		MaxGames:       request.MaxGames,
		MaxTags:        request.MaxTags,
		AllowDeleted:   request.AllowDeleted,
		AllowInvisible: request.AllowInvisible,
		Language:       searchdomain.Language(request.Language),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to search: %w", err)
	}

	return &model.SearchResponse{
		SearchItems: model.SearchItems{}.FromDomain(searchRes),
	}, nil
}

// FullSearch is the resolver for the fullSearch field.
func (r *queryResolver) FullSearch(ctx context.Context, request model.FullSearchRequest) (*model.SearchResponse, error) {
	searchRes, err := r.searchService.FullSearch(ctx, searchdomain.FullSearchRequest{
		Query:          request.Query,
		Page:           request.Page,
		Limit:          request.Limit,
		AllowDeleted:   request.AllowDeleted,
		AllowInvisible: request.AllowInvisible,
		Sort:           searchdomain.SortingMethod(request.Sort.Domain()),
		Language:       searchdomain.Language(request.Language),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to search: %w", err)
	}

	return &model.SearchResponse{
		SearchItems: model.SearchItems{}.FromDomain(searchRes),
	}, nil
}

// RandomProviderGame is the resolver for the randomProviderGame field.
func (r *queryResolver) RandomProviderGame(ctx context.Context) (*model.RandomProviderGameResponse, error) {
	fetcherRes, err := r.fetcherClient.Fetch()
	if err != nil {
		return nil, fmt.Errorf("failed to fetch game: %w", err)
	}

	res := model.RandomProviderGameResponse(fetcherRes)

	return &res, nil
}

// AvailableLanguages is the resolver for the availableLanguages field.
func (r *queryResolver) AvailableLanguages(ctx context.Context) (*model.AvailableLanguagesResponse, error) {
	return &model.AvailableLanguagesResponse{
		Languages: []*model.AvailableLanguage{
			{
				Code: model.LanguageEn,
				Name: "English",
			},
		},
	}, nil
}

// PromotedTags is the resolver for the promotedTags field.
func (r *queryResolver) PromotedTags(ctx context.Context, language model.Language) ([]*model.PromotedTag, error) {
	// brain
	// match-3
	// word
	// time management

	// we need 4 tags here
	return []*model.PromotedTag{
		{
			ID:        0,
			Slug:      "",
			Name:      "",
			Icon:      "",
			Thumbnail: "",
		},
	}, nil
}

// TopTags is the resolver for the topTags field.
func (r *queryResolver) TopTags(ctx context.Context, language model.Language) ([]*model.TopTag, error) {
	// Cooking
	// Match-3
	// Brain
	// Time Management
	// Puzzle
	// Educational
	// Solitaire

	// we need 7 tags here
	return []*model.TopTag{
		{
			ID:        0,
			Slug:      "",
			Name:      "",
			Thumbnail: "",
		},
	}, nil
}

// WhatOthersPlay is the resolver for the whatOthersPlay field.
func (r *queryResolver) WhatOthersPlay(ctx context.Context, language model.Language) (*model.GamesResponse, error) {
	res, err := r.gameService.GetMostPlayedByDays(ctx, gamedomain.GetMostPlayedByDaysRequest{
		Page:       1,
		Limit:      10,
		MaxDays:    14,
		Language:   gamedomain.LanguageEnglish,
		MobileOnly: false,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get most played games: %w", err)
	}

	return &model.GamesResponse{
		Games: model.Games{}.FromDomain(res.Data),
	}, nil
}

// Quote is the resolver for the quote field.
func (r *queryResolver) Quote(ctx context.Context, language model.Language) (*model.Quote, error) {
	res, err := r.quoteService.Get()
	if err != nil {
		return nil, fmt.Errorf("failed to get: %w", err)
	}

	return &model.Quote{
		Message:   res.Quote,
		Author:    res.Author,
		ExpiresAt: res.ExpiresAt.UTC().String(),
	}, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
