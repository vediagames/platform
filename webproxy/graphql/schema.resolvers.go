package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.28

import (
	"context"
	"fmt"
	"strconv"

	"github.com/rs/zerolog"

	gamedomain "github.com/vediagames/platform/game/domain"
	model1 "github.com/vediagames/platform/gateway/graphql/model"
	"github.com/vediagames/platform/webproxy/graphql/generated"
	"github.com/vediagames/platform/webproxy/graphql/model"
)

// Category is the resolver for the category field.
func (r *categoryPageResponseResolver) Category(ctx context.Context, obj *model.CategoryPageResponse) (*model1.Category, error) {
	gatewayRes, err := r.gatewayResolver.Query().Category(ctx, model1.CategoryRequest{
		Field:    model1.GetByFieldSlug,
		Value:    obj.Slug,
		Language: obj.Language,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to query: %w", err)
	}

	return gatewayRes.Category, nil
}

// TagSections is the resolver for the tagSections field.
func (r *categoryPageResponseResolver) TagSections(ctx context.Context, obj *model.CategoryPageResponse) (*model1.TagSections, error) {
	tagLayout, ok := CategoryPageLayouts[obj.Slug]
	if !ok {
		return nil, fmt.Errorf("invalid layout slug: %q", obj.Slug)
	}

	tagSections := &model1.TagSections{
		Data:  make([]*model1.TagSection, 0, len(tagLayout)),
		Total: len(tagLayout),
	}

	for _, tag := range tagLayout {
		tagRes, err := r.gatewayResolver.Query().Tag(ctx, model1.TagRequest{
			Field:    model1.GetByFieldSlug,
			Value:    tag,
			Language: obj.Language,
		})
		if err != nil {
			return nil, fmt.Errorf("failed to get tag %q: %w", tag, err)
		}

		gamesRes, err := r.gatewayResolver.Query().Games(ctx, model1.GamesRequest{
			Language: obj.Language,
			Page:     1,
			Limit:    7,
			Sort:     sortingMethodToPointer(model1.SortingMethodMostPopular),
			Tags:     gamedomain.IDs{tagRes.Tag.ID},
		})
		if err != nil {
			return nil, fmt.Errorf("failed to get games for tag %q: %w", tag, err)
		}

		tagSection := &model1.TagSection{
			Games: gamesRes.Games,
			Tag:   tagRes.Tag,
		}

		tagSections.Data = append(tagSections.Data, tagSection)
	}

	return tagSections, nil
}

// Tags is the resolver for the tags field.
func (r *categoryPageResponseResolver) Tags(ctx context.Context, obj *model.CategoryPageResponse) (*model1.Tags, error) {
	gatewayRes, err := r.gatewayResolver.Query().Tags(ctx, model1.TagsRequest{
		Language: obj.Language,
		Page:     1,
		Limit:    11,
		Sort:     sortingMethodToPointer(model1.SortingMethodRandom),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to query: %w", err)
	}

	return gatewayRes.Tags, nil
}

// Games is the resolver for the games field.
func (r *categoryPageResponseResolver) Games(ctx context.Context, obj *model.CategoryPageResponse) (*model.CategoryPageGames, error) {
	gamesRes, err := r.gatewayResolver.Query().Games(ctx, model1.GamesRequest{
		Language:   obj.Language,
		Page:       1,
		Limit:      22,
		Sort:       sortingMethodToPointer(model1.SortingMethodMostPopular),
		Categories: gamedomain.IDs{obj.ID},
	})
	if err != nil {
		return nil, fmt.Errorf("failed to query: %w", err)
	}

	firstSectionGames := gamesRes.Games
	otherGames := &model1.Games{}

	if len(gamesRes.Games.Data) > 7 {
		firstSectionGames = &model1.Games{
			Data:  gamesRes.Games.Data[:7],
			Total: gamesRes.Games.Total,
		}

		otherGames = &model1.Games{
			Data:  gamesRes.Games.Data[7:],
			Total: gamesRes.Games.Total,
		}
	}

	return &model.CategoryPageGames{
		FirstSectionGames: firstSectionGames,
		OtherGames:        otherGames,
	}, nil
}

// TotalGames is the resolver for the totalGames field.
func (r *homePageResponseResolver) TotalGames(ctx context.Context, obj *model.HomePageResponse) (int, error) {
	gatewayRes, err := r.gatewayResolver.Query().Games(ctx, model1.GamesRequest{
		Language: obj.Language,
		Page:     1,
		Limit:    1,
	})
	if err != nil {
		return 0, fmt.Errorf("failed to query: %w", err)
	}

	return gatewayRes.Games.Total, nil
}

// MostPlayedGamesInLast7Days is the resolver for the mostPlayedGamesInLast7Days field.
func (r *homePageResponseResolver) MostPlayedGamesInLast7Days(ctx context.Context, obj *model.HomePageResponse) (*model1.Games, error) {
	gatewayRes, err := r.gatewayResolver.Query().MostPlayedGames(ctx, model1.MostPlayedGamesRequest{
		Language: obj.Language,
		Page:     1,
		Limit:    4,
		MaxDays:  7,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to query: %w", err)
	}

	return gatewayRes.Games, nil
}

// GamesAddedInLast7Days is the resolver for the gamesAddedInLast7Days field.
func (r *homePageResponseResolver) GamesAddedInLast7Days(ctx context.Context, obj *model.HomePageResponse) (*model1.Games, error) {
	gatewayRes, err := r.gatewayResolver.Query().FreshGames(ctx, model1.FreshGamesRequest{
		Language: obj.Language,
		Page:     1,
		Limit:    4,
		MaxDays:  7,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to query: %w", err)
	}

	return gatewayRes.Games, nil
}

// MostPlayedGames is the resolver for the mostPlayedGames field.
func (r *homePageResponseResolver) MostPlayedGames(ctx context.Context, obj *model.HomePageResponse) (*model1.Games, error) {
	gatewayRes, err := r.gatewayResolver.Query().Games(ctx, model1.GamesRequest{
		Language: obj.Language,
		Page:     1,
		Limit:    40,
		Sort:     sortingMethodToPointer(model1.SortingMethodName),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to query: %w", err)
	}

	return gatewayRes.Games, nil
}

// Sections is the resolver for the sections field.
func (r *homePageResponseResolver) Sections(ctx context.Context, obj *model.HomePageResponse) (*model1.PlacedSections, error) {
	gatewayRes, err := r.gatewayResolver.Query().PlacedSections(ctx, model1.PlacedSectionsRequest{
		Language: obj.Language,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to query: %w", err)
	}

	for _, websitePlacement := range gatewayRes.PlacedSections.Data {
		var gamesReq model1.GamesRequest

		switch websitePlacement.Section.Slug {
		case "continue-playing":
			if len(obj.LastPlayedGameIDs) <= 0 {
				continue
			}

			gamesReq = model1.GamesRequest{
				Language: obj.Language,
				Page:     1,
				Limit:    10,
				Ids:      obj.LastPlayedGameIDs,
			}
		case "newest":
			gamesReq = model1.GamesRequest{
				Language: obj.Language,
				Page:     1,
				Limit:    10,
				Sort:     sortingMethodToPointer(model1.SortingMethodNewest),
			}
		default:
			if len(websitePlacement.Section.CategoryIDRefs) == 0 &&
				len(websitePlacement.Section.GameIDRefs) == 0 &&
				len(websitePlacement.Section.TagIDRefs) == 0 {
				zerolog.Ctx(ctx).Err(fmt.Errorf("invalid section: %s, no elements", websitePlacement.Section.Slug))
			}

			gamesReq = model1.GamesRequest{
				Language:   obj.Language,
				Page:       1,
				Limit:      10,
				Sort:       sortingMethodToPointer(model1.SortingMethodRandom),
				Categories: websitePlacement.Section.CategoryIDRefs,
				Tags:       websitePlacement.Section.TagIDRefs,
				Ids:        websitePlacement.Section.GameIDRefs,
			}
		}

		gamesRes, err := r.gatewayResolver.Query().Games(ctx, gamesReq)
		if err != nil {
			return nil, fmt.Errorf("failed to list games for section %q: %w", websitePlacement.Section.Slug, err)
		}

		websitePlacement.Section.Games = gamesRes.Games
	}

	return gatewayRes.PlacedSections, nil
}

// TagSections is the resolver for the tagSections field.
func (r *homePageResponseResolver) TagSections(ctx context.Context, obj *model.HomePageResponse) (*model1.TagSections, error) {
	gatewayRes, err := r.gatewayResolver.Query().Tags(ctx, model1.TagsRequest{
		Language: obj.Language,
		Page:     1,
		Limit:    11,
		Sort:     sortingMethodToPointer(model1.SortingMethodRandom),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to query: %w", err)
	}

	tagSections := &model1.TagSections{
		Data:  make([]*model1.TagSection, 0, len(gatewayRes.Tags.Data)),
		Total: gatewayRes.Tags.Total,
	}

	for _, tag := range gatewayRes.Tags.Data {
		gamesRes, err := r.gatewayResolver.Query().Games(ctx, model1.GamesRequest{
			Language: obj.Language,
			Page:     1,
			Limit:    7,
			Tags:     []int{tag.ID},
			Sort:     sortingMethodToPointer(model1.SortingMethodRandom),
		})
		if err != nil {
			return nil, fmt.Errorf("failed to list games for tag %q: %w", tag.Name, err)
		}

		tagSections.Data = append(tagSections.Data, &model1.TagSection{
			Games: gamesRes.Games,
			Tag:   tag,
		})
	}

	return tagSections, nil
}

// HomePage is the resolver for the homePage field.
func (r *queryResolver) HomePage(ctx context.Context, request model.HomePageRequest) (*model.HomePageResponse, error) {
	return &model.HomePageResponse{
		Language:          request.Language,
		LastPlayedGameIDs: request.LastPlayedGameIDs,
	}, nil
}

// GamePage is the resolver for the gamePage field.
func (r *queryResolver) GamePage(ctx context.Context, request model.GamePageRequest) (*model.GamePageResponse, error) {
	var tagsToIgnore = map[int]string{
		12: "boys",
		13: "girls",
		21: "challenge",
		54: "brain",
	}

	gameRes, err := r.gatewayResolver.Query().Game(ctx, model1.GameRequest{
		Field:    model1.GetByFieldSlug,
		Value:    request.Slug,
		Language: request.Language,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get game: %w", err)
	}

	tagIDs := make([]int, 0, len(gameRes.Game.TagIDRefs))
	for _, tag := range gameRes.Game.TagIDRefs {
		if _, ok := tagsToIgnore[tag]; !ok {
			tagIDs = append(tagIDs, tag)
		}
	}

	otherGamesRes, err := r.gatewayResolver.Query().Games(ctx, model1.GamesRequest{
		Language:        request.Language,
		Page:            1,
		Limit:           8,
		Sort:            sortingMethodToPointer(model1.SortingMethodRandom),
		Categories:      gameRes.Game.CategoryIDRefs,
		Tags:            tagIDs,
		ExcludedGameIDs: []int{gameRes.Game.ID},
	})
	if err != nil {
		return nil, fmt.Errorf("failed to list games: %w", err)
	}

	return &model.GamePageResponse{
		Game:       gameRes.Game,
		OtherGames: otherGamesRes.Games,
		IsLiked:    false,
		IsDisliked: false,
	}, nil
}

// ContinuePlayingPage is the resolver for the continuePlayingPage field.
func (r *queryResolver) ContinuePlayingPage(ctx context.Context, request model.ContinuePlayingPageRequest) (*model.ContinuePlayingPageResponse, error) {
	gameRes, err := r.gatewayResolver.Query().Games(ctx, model1.GamesRequest{
		Language: request.Language,
		Page:     request.Page,
		Limit:    15,
		Ids:      request.LastPlayedGameIDs,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to list games: %w", err)
	}

	// order by last played game ids
	orderedGames := &model1.Games{
		Data:  make([]*model1.Game, 0, len(gameRes.Games.Data)),
		Total: gameRes.Games.Total,
	}

	for _, game := range gameRes.Games.Data {
		orderedGames.Data = append(orderedGames.Data, game)
	}

	return &model.ContinuePlayingPageResponse{
		Games: orderedGames,
	}, nil
}

// FilterPage is the resolver for the filterPage field.
func (r *queryResolver) FilterPage(ctx context.Context, request model.FilterPageRequest) (*model.FilterPageResponse, error) {
	gameRes, err := r.gatewayResolver.Query().Games(ctx, model1.GamesRequest{
		Language:   request.Language,
		Page:       request.Page,
		Limit:      15,
		Sort:       request.Sort,
		Categories: request.CategoryIDs,
		Tags:       request.TagIDs,
		Ids:        request.GameIDs,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to list games: %w", err)
	}

	return &model.FilterPageResponse{
		Games: gameRes.Games,
	}, nil
}

// SearchPage is the resolver for the searchPage field.
func (r *queryResolver) SearchPage(ctx context.Context, request model.SearchPageRequest) (*model.SearchPageResponse, error) {
	req := model1.FullSearchRequest{
		Language:       request.Language,
		Query:          request.Query,
		Page:           request.Page,
		Limit:          15,
		Sort:           request.Sort,
		AllowDeleted:   false,
		AllowInvisible: false,
	}

	searchRes, err := r.gatewayResolver.Query().FullSearch(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to full search: %w", err)
	}

	return &model.SearchPageResponse{
		Items:        searchRes.SearchItems,
		ShowingRange: fmt.Sprintf("%d-%d", req.Limit*(req.Page-1)+1, req.Limit*(req.Page-1)+len(searchRes.SearchItems.Data)),
	}, nil
}

// SiteMapPage is the resolver for the siteMapPage field.
func (r *queryResolver) SiteMapPage(ctx context.Context, request model.SiteMapPageRequest) (*model.SiteMapPageResponse, error) {
	categoryRes, err := r.gatewayResolver.Query().Categories(ctx, model1.CategoriesRequest{
		Language: request.Language,
		Page:     1,
		Limit:    1000,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to list categories: %w", err)
	}

	return &model.SiteMapPageResponse{
		Categories: categoryRes.Categories,
	}, nil
}

// WizardPage is the resolver for the wizardPage field.
func (r *queryResolver) WizardPage(ctx context.Context, request model.WizardPageRequest) (*model.WizardPageResponse, error) {
	return &model.WizardPageResponse{
		Language:    request.Language,
		CategoryIDs: request.CategoryIDs,
	}, nil
}

// TagPage is the resolver for the tagPage field.
func (r *queryResolver) TagPage(ctx context.Context, request model.TagPageRequest) (*model.TagPageResponse, error) {
	return &model.TagPageResponse{
		Page:     request.Page,
		Language: request.Language,
		ID:       request.ID,
	}, nil
}

// TagsPage is the resolver for the tagsPage field.
func (r *queryResolver) TagsPage(ctx context.Context, request model.TagsPageRequest) (*model.TagsPageResponse, error) {
	tagRes, err := r.gatewayResolver.Query().Tags(ctx, model1.TagsRequest{
		Language: request.Language,
		Page:     request.Page,
		Limit:    15,
		Sort:     sortingMethodToPointer(model1.SortingMethodName),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to list tags: %w", err)
	}

	return &model.TagsPageResponse{
		Tags: tagRes.Tags,
	}, nil
}

// CategoryPage is the resolver for the categoryPage field.
func (r *queryResolver) CategoryPage(ctx context.Context, request model.CategoryPageRequest) (*model.CategoryPageResponse, error) {
	return &model.CategoryPageResponse{
		Language: request.Language,
		Slug:     request.Slug,
		ID:       request.ID,
	}, nil
}

// CategoriesPage is the resolver for the categoriesPage field.
func (r *queryResolver) CategoriesPage(ctx context.Context, request model.CategoriesPageRequest) (*model.CategoriesPageResponse, error) {
	categoryRes, err := r.gatewayResolver.Query().Categories(ctx, model1.CategoriesRequest{
		Language: request.Language,
		Page:     1,
		Limit:    1000,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to list categories: %w", err)
	}

	return &model.CategoriesPageResponse{
		Categories: categoryRes.Categories,
	}, nil
}

// Tag is the resolver for the tag field.
func (r *tagPageResponseResolver) Tag(ctx context.Context, obj *model.TagPageResponse) (*model1.Tag, error) {
	tagRes, err := r.gatewayResolver.Query().Tag(ctx, model1.TagRequest{
		Field:    model1.GetByFieldID,
		Value:    strconv.Itoa(obj.ID),
		Language: obj.Language,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get tag: %w", err)
	}

	return tagRes.Tag, nil
}

// Games is the resolver for the games field.
func (r *tagPageResponseResolver) Games(ctx context.Context, obj *model.TagPageResponse) (*model1.Games, error) {
	gameRes, err := r.gatewayResolver.Query().Games(ctx, model1.GamesRequest{
		Language: obj.Language,
		Page:     obj.Page,
		Limit:    15,
		Tags:     []int{obj.ID},
		Sort:     sortingMethodToPointer(model1.SortingMethodMostPopular),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to list games: %w", err)
	}

	return gameRes.Games, nil
}

// Categories is the resolver for the categories field.
func (r *wizardPageResponseResolver) Categories(ctx context.Context, obj *model.WizardPageResponse) (*model1.Categories, error) {
	gatewayRes, err := r.gatewayResolver.Query().Categories(ctx, model1.CategoriesRequest{
		Language: obj.Language,
		Page:     1,
		Limit:    20,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to query: %w", err)
	}

	return gatewayRes.Categories, nil
}

// Games is the resolver for the games field.
func (r *wizardPageResponseResolver) Games(ctx context.Context, obj *model.WizardPageResponse) (*model1.Games, error) {
	gatewayRes, err := r.gatewayResolver.Query().Games(ctx, model1.GamesRequest{
		Language:   obj.Language,
		Page:       1,
		Limit:      4,
		Sort:       sortingMethodToPointer(model1.SortingMethodMostPopular),
		Categories: obj.CategoryIDs,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to query: %w", err)
	}

	return gatewayRes.Games, nil
}

// CategoryPageResponse returns generated.CategoryPageResponseResolver implementation.
func (r *Resolver) CategoryPageResponse() generated.CategoryPageResponseResolver {
	return &categoryPageResponseResolver{r}
}

// HomePageResponse returns generated.HomePageResponseResolver implementation.
func (r *Resolver) HomePageResponse() generated.HomePageResponseResolver {
	return &homePageResponseResolver{r}
}

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

// TagPageResponse returns generated.TagPageResponseResolver implementation.
func (r *Resolver) TagPageResponse() generated.TagPageResponseResolver {
	return &tagPageResponseResolver{r}
}

// WizardPageResponse returns generated.WizardPageResponseResolver implementation.
func (r *Resolver) WizardPageResponse() generated.WizardPageResponseResolver {
	return &wizardPageResponseResolver{r}
}

type categoryPageResponseResolver struct{ *Resolver }
type homePageResponseResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type tagPageResponseResolver struct{ *Resolver }
type wizardPageResponseResolver struct{ *Resolver }
