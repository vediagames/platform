package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.27

import (
	"context"
	"fmt"
	"strconv"

	"github.com/rs/zerolog"

	gamedomain "github.com/vediagames/platform/game/domain"
	"github.com/vediagames/platform/gateway/graphql/model"
	"github.com/vediagames/platform/webproxy/vediagames/graphql/generated"
	model1 "github.com/vediagames/platform/webproxy/vediagames/graphql/model"
)

// GetHomePage is the resolver for the getHomePage field.
func (r *queryResolver) GetHomePage(ctx context.Context, request model1.GetHomePageRequest) (*model1.GetHomePageResponse, error) {
	totalGamesRes, err := r.gameService.List(ctx, gamedomain.ListRequest{
		Sort:           gamedomain.SortingMethodID,
		Language:       gamedomain.LanguageEnglish,
		Page:           1,
		Limit:          1,
		AllowDeleted:   false,
		AllowInvisible: false,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get total games: %w", err)
	}

	gamesAddedInLast7Days, err := r.gatewayResolver.FreshGames(ctx, model.FreshGamesRequest{
		Language: request.Language,
		Page:     1,
		Limit:    4,
		MaxDays:  7,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get fresh games: %w", err)
	}

	mostPlayedGamesInLast7Days, err := r.gatewayResolver.MostPlayedGames(ctx, model.MostPlayedGamesRequest{
		Language: request.Language,
		Page:     1,
		Limit:    4,
		MaxDays:  7,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get most played games in last 7 days: %w", err)
	}

	mostPlayedGames, err := r.gatewayResolver.Games(ctx, model.GamesRequest{
		Language: request.Language,
		Page:     1,
		Limit:    40,
		Sort:     sortingMethodToPointer(model.SortingMethodName),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get most played games: %w", err)
	}

	websiteSectionPlacements, err := r.gatewayResolver.PlacedSections(ctx, model.PlacedSectionsRequest{
		Language: request.Language,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get website sections placement: %w", err)
	}

	for _, websitePlacement := range websiteSectionPlacements.PlacedSections.Data {
		var gamesReq model.GamesRequest

		switch websitePlacement.Section.Slug {
		case "continue-playing":
			if len(request.LastPlayedGameIDs) <= 0 {
				continue
			}

			gamesReq = model.GamesRequest{
				Language: request.Language,
				Page:     1,
				Limit:    10,
				Ids:      request.LastPlayedGameIDs,
			}
		case "newest":
			gamesReq = model.GamesRequest{
				Language: request.Language,
				Page:     1,
				Limit:    10,
				Sort:     sortingMethodToPointer(model.SortingMethodNewest),
			}
		default:
			var categoryIDs []int
			if websitePlacement.Section.Categories != nil {
				categoryIDs = websitePlacement.Section.Categories.IDs()
			}

			var tagIDs []int
			if websitePlacement.Section.Tags != nil {
				tagIDs = websitePlacement.Section.Tags.IDs()
			}

			var gameIDs []int
			if websitePlacement.Section.Games != nil {
				gameIDs = websitePlacement.Section.Games.IDs()
			}

			if len(categoryIDs) == 0 && len(gameIDs) == 0 && len(tagIDs) == 0 {
				zerolog.Ctx(ctx).Err(fmt.Errorf("invalid section: %s, no elements", websitePlacement.Section.Slug))
			}

			gamesReq = model.GamesRequest{
				Language:   request.Language,
				Page:       1,
				Limit:      10,
				Sort:       sortingMethodToPointer(model.SortingMethodRandom),
				Categories: categoryIDs,
				Tags:       tagIDs,
				Ids:        gameIDs,
			}
		}

		gamesRes, err := r.gatewayResolver.Games(ctx, gamesReq)
		if err != nil {
			return nil, fmt.Errorf("failed to list games for section %q: %w", websitePlacement.Section.Slug, err)
		}

		websitePlacement.Section.Games = gamesRes.Games
	}

	tagsRes, err := r.gatewayResolver.Tags(ctx, model.TagsRequest{
		Language: request.Language,
		Page:     1,
		Limit:    11,
		Sort:     sortingMethodToPointer(model.SortingMethodRandom),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to list tags: %w", err)
	}

	tagSections := &model.TagSections{
		Data:  make([]*model.TagSection, 0, len(tagsRes.Tags.Data)),
		Total: tagsRes.Tags.Total,
	}

	for _, tag := range tagsRes.Tags.Data {
		gamesRes, err := r.gatewayResolver.Games(ctx, model.GamesRequest{
			Language: request.Language,
			Page:     1,
			Limit:    7,
			Tags:     []int{tag.ID},
			Sort:     sortingMethodToPointer(model.SortingMethodRandom),
		})
		if err != nil {
			return nil, fmt.Errorf("failed to list games for tag %q: %w", tag.Name, err)
		}

		tagSections.Data = append(tagSections.Data, &model.TagSection{
			Games: gamesRes.Games,
			Tag:   tag,
		})
	}

	return &model1.GetHomePageResponse{
		TotalGames:                 totalGamesRes.Data.Total,
		TotalGamesAddedInLast7Days: gamesAddedInLast7Days.Games.Total,
		MostPlayedGamesInLast7Days: mostPlayedGamesInLast7Days.Games,
		GamesAddedInLast7Days:      gamesAddedInLast7Days.Games,
		MostPlayedGames:            mostPlayedGames.Games,
		Sections:                   websiteSectionPlacements.PlacedSections,
		TagSections:                tagSections,
	}, nil
}

// GetGamePage is the resolver for the getGamePage field.
func (r *queryResolver) GetGamePage(ctx context.Context, request model1.GetGamePageRequest) (*model1.GetGamePageResponse, error) {
	var tagsToIgnore = map[int]string{
		12: "boys",
		13: "girls",
		21: "challenge",
		54: "brain",
	}

	gameRes, err := r.gatewayResolver.Game(ctx, model.GameRequest{
		Field:    model.GetByFieldSlug,
		Value:    request.Slug,
		Language: request.Language,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get game: %w", err)
	}

	tagIDs := make([]int, 0, len(gameRes.Game.Tags.Data))
	for _, tag := range gameRes.Game.Tags.Data {
		if _, ok := tagsToIgnore[tag.ID]; !ok {
			tagIDs = append(tagIDs, tag.ID)
		}
	}

	categoryIDs := make([]int, 0, len(gameRes.Game.Categories.Data))
	for _, category := range gameRes.Game.Categories.Data {
		categoryIDs = append(categoryIDs, category.ID)
	}

	otherGamesRes, err := r.gatewayResolver.Games(ctx, model.GamesRequest{
		Language:        request.Language,
		Page:            1,
		Limit:           8,
		Sort:            sortingMethodToPointer(model.SortingMethodRandom),
		Categories:      categoryIDs,
		Tags:            tagIDs,
		ExcludedGameIDs: []int{gameRes.Game.ID},
	})
	if err != nil {
		return nil, fmt.Errorf("failed to list games: %w", err)
	}

	return &model1.GetGamePageResponse{
		Game:       gameRes.Game,
		OtherGames: otherGamesRes.Games,
		IsLiked:    false,
		IsDisliked: false,
	}, nil
}

// GetContinuePlayingPage is the resolver for the getContinuePlayingPage field.
func (r *queryResolver) GetContinuePlayingPage(ctx context.Context, request model1.GetContinuePlayingPageRequest) (*model1.GetContinuePlayingPageResponse, error) {
	gameRes, err := r.gatewayResolver.Games(ctx, model.GamesRequest{
		Language: request.Language,
		Page:     request.Page,
		Limit:    15,
		Ids:      request.LastPlayedGameIDs,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to list games: %w", err)
	}

	// order by last played game ids
	orderedGames := &model.Games{
		Data:  make([]*model.Game, 0, len(gameRes.Games.Data)),
		Total: gameRes.Games.Total,
	}

	for i, game := range gameRes.Games.Data {
		for _, id := range request.LastPlayedGameIDs {
			if game.ID == id {
				orderedGames.Data[i] = game
			}
		}
	}

	return &model1.GetContinuePlayingPageResponse{
		Games: orderedGames,
	}, nil
}

// GetFilterPage is the resolver for the getFilterPage field.
func (r *queryResolver) GetFilterPage(ctx context.Context, request model1.GetFilterPageRequest) (*model1.GetFilterPageResponse, error) {
	gameRes, err := r.gatewayResolver.Games(ctx, model.GamesRequest{
		Language:   request.Language,
		Page:       request.Page,
		Limit:      15,
		Sort:       request.Sort,
		Categories: request.CategoryIDs,
		Tags:       request.TagIDs,
		Ids:        request.GameIDs,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to list games: %w", err)
	}

	return &model1.GetFilterPageResponse{
		Games: gameRes.Games,
	}, nil
}

// GetSearchPage is the resolver for the getSearchPage field.
func (r *queryResolver) GetSearchPage(ctx context.Context, request model1.GetSearchPageRequest) (*model1.GetSearchPageResponse, error) {
	req := model.FullSearchRequest{
		Language:       request.Language,
		Query:          request.Query,
		Page:           request.Page,
		Limit:          15,
		Sort:           request.Sort,
		AllowDeleted:   false,
		AllowInvisible: false,
	}

	searchRes, err := r.gatewayResolver.FullSearch(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to full search: %w", err)
	}

	return &model1.GetSearchPageResponse{
		Items:        searchRes.SearchItems,
		ShowingRange: fmt.Sprintf("%d-%d", req.Limit*(req.Page-1)+1, req.Limit*(req.Page-1)+len(searchRes.SearchItems.Data)),
	}, nil
}

// GetSiteMapPage is the resolver for the getSiteMapPage field.
func (r *queryResolver) GetSiteMapPage(ctx context.Context, request model1.GetSiteMapPageRequest) (*model1.GetSiteMapPageResponse, error) {
	categoryRes, err := r.gatewayResolver.Categories(ctx, model.CategoriesRequest{
		Language: request.Language,
		Page:     1,
		Limit:    1000,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to list categories: %w", err)
	}

	return &model1.GetSiteMapPageResponse{
		Categories: categoryRes.Categories,
	}, nil
}

// GetWizardPage is the resolver for the getWizardPage field.
func (r *queryResolver) GetWizardPage(ctx context.Context, request model1.GetWizardPageRequest) (*model1.GetWizardPageResponse, error) {
	categoryRes, err := r.gatewayResolver.Categories(ctx, model.CategoriesRequest{
		Language: request.Language,
		Page:     1,
		Limit:    1000,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to list categories: %w", err)
	}

	gameRes, err := r.gatewayResolver.Games(ctx, model.GamesRequest{
		Language:   request.Language,
		Page:       1,
		Limit:      4,
		Sort:       sortingMethodToPointer(model.SortingMethodMostPopular),
		Categories: request.CategoryIDs,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to list games: %w", err)
	}

	return &model1.GetWizardPageResponse{
		Categories: categoryRes.Categories,
		Games:      gameRes.Games,
	}, nil
}

// GetTagPage is the resolver for the getTagPage field.
func (r *queryResolver) GetTagPage(ctx context.Context, request model1.GetTagPageRequest) (*model1.GetTagPageResponse, error) {
	tagRes, err := r.gatewayResolver.Tag(ctx, model.TagRequest{
		Field:    model.GetByFieldID,
		Value:    strconv.Itoa(request.TagID),
		Language: request.Language,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get tag: %w", err)
	}

	gameRes, err := r.gatewayResolver.Games(ctx, model.GamesRequest{
		Language: request.Language,
		Page:     request.Page,
		Limit:    15,
		Tags:     []int{request.TagID},
		Sort:     sortingMethodToPointer(model.SortingMethodMostPopular),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to list games: %w", err)
	}

	return &model1.GetTagPageResponse{
		Tag:   tagRes.Tag,
		Games: gameRes.Games,
	}, nil
}

// GetTagsPage is the resolver for the getTagsPage field.
func (r *queryResolver) GetTagsPage(ctx context.Context, request model1.GetTagsPageRequest) (*model1.GetTagsPageResponse, error) {
	tagRes, err := r.gatewayResolver.Tags(ctx, model.TagsRequest{
		Language: request.Language,
		Page:     request.Page,
		Limit:    15,
		Sort:     sortingMethodToPointer(model.SortingMethodName),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to list tags: %w", err)
	}

	return &model1.GetTagsPageResponse{
		Tags: tagRes.Tags,
	}, nil
}

// GetCategoryPage is the resolver for the getCategoryPage field.
func (r *queryResolver) GetCategoryPage(ctx context.Context, request model1.GetCategoryPageRequest) (*model1.GetCategoryPageResponse, error) {
	tagLayout, ok := CategoryPageLayouts[request.Slug]
	if !ok {
		return nil, fmt.Errorf("invalid layout slug: %q", request.Slug)
	}

	categoryRes, err := r.gatewayResolver.Category(ctx, model.CategoryRequest{
		Field:    model.GetByFieldSlug,
		Value:    request.Slug,
		Language: request.Language,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get category: %w", err)
	}

	gamesRes, err := r.gatewayResolver.Games(ctx, model.GamesRequest{
		Language:   request.Language,
		Page:       1,
		Limit:      22,
		Sort:       sortingMethodToPointer(model.SortingMethodMostPopular),
		Categories: gamedomain.IDs{categoryRes.Category.ID},
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get first section games: %w", err)
	}

	tagSections := &model.TagSections{
		Data:  make([]*model.TagSection, 0, len(tagLayout)),
		Total: len(tagLayout),
	}

	for _, tag := range tagLayout {
		tagRes, err := r.gatewayResolver.Tag(ctx, model.TagRequest{
			Field:    model.GetByFieldSlug,
			Value:    tag,
			Language: request.Language,
		})
		if err != nil {
			return nil, fmt.Errorf("failed to get tag %q: %w", tag, err)
		}

		gamesRes, err := r.gatewayResolver.Games(ctx, model.GamesRequest{
			Language: request.Language,
			Page:     1,
			Limit:    7,
			Sort:     sortingMethodToPointer(model.SortingMethodMostPopular),
			Tags:     gamedomain.IDs{tagRes.Tag.ID},
		})
		if err != nil {
			return nil, fmt.Errorf("failed to get games for tag %q: %w", tag, err)
		}

		tagSection := &model.TagSection{
			Games: gamesRes.Games,
			Tag:   tagRes.Tag,
		}

		tagSections.Data = append(tagSections.Data, tagSection)
	}

	randomTagsRes, err := r.gatewayResolver.Tags(ctx, model.TagsRequest{
		Language: request.Language,
		Page:     1,
		Limit:    11,
		Sort:     sortingMethodToPointer(model.SortingMethodRandom),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get random tags: %w", err)
	}

	firstSectionGames := gamesRes
	otherGames := &model.GamesResponse{}

	if len(gamesRes.Games.Data) > 7 {
		firstSectionGames = &model.GamesResponse{
			Games: &model.Games{
				Data:  gamesRes.Games.Data[:7],
				Total: gamesRes.Games.Total,
			},
		}

		otherGames = &model.GamesResponse{
			Games: &model.Games{
				Data:  gamesRes.Games.Data[7:],
				Total: gamesRes.Games.Total,
			},
		}
	}

	return &model1.GetCategoryPageResponse{
		Category:          categoryRes.Category,
		FirstSectionGames: firstSectionGames.Games,
		TagSections:       tagSections,
		Tags:              randomTagsRes.Tags,
		OtherGames:        otherGames.Games,
	}, nil
}

// GetCategoriesPage is the resolver for the getCategoriesPage field.
func (r *queryResolver) GetCategoriesPage(ctx context.Context, request model1.GetCategoriesPageRequest) (*model1.GetCategoriesPageResponse, error) {
	categoryRes, err := r.gatewayResolver.Categories(ctx, model.CategoriesRequest{
		Language: request.Language,
		Page:     1,
		Limit:    1000,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to list categories: %w", err)
	}

	return &model1.GetCategoriesPageResponse{
		Categories: categoryRes.Categories,
	}, nil
}

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
